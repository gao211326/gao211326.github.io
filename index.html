<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="One Dream" />


    
    


<meta name="description" content="不积跬步无以至千里，不积小流无以成江海">
<meta property="og:type" content="website">
<meta property="og:title" content="半笑半醉间">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="半笑半醉间">
<meta property="og:description" content="不积跬步无以至千里，不积小流无以成江海">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="半笑半醉间">
<meta name="twitter:description" content="不积跬步无以至千里，不积小流无以成江海">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="半笑半醉间" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/orange/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>半笑半醉间</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">One Dream</a></h1>
        </hgroup>

        
        <p class="header-subtitle">人生为棋，我愿为卒，行动虽慢，可谁曾见我后退半步</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/gao211326" title="GitHub"></a>
                            
                                <a class="fa 简书" href="http://www.jianshu.com/u/d772826c5def" title="简书"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">One Dream</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">One Dream</a></h1>
            </hgroup>
            
            <p class="header-subtitle">人生为棋，我愿为卒，行动虽慢，可谁曾见我后退半步</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/gao211326" title="GitHub"></a>
                            
                                <a class="fa 简书" target="_blank" href="http://www.jianshu.com/u/d772826c5def" title="简书"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Go 语言之Mac环境配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/19/Go 语言之Mac环境配置/" class="article-date">
      <time datetime="2017-05-18T16:00:00.000Z" itemprop="datePublished">2017-05-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/19/Go 语言之Mac环境配置/">Go 语言之Mac环境配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&lt;Excerpt in index | 首页摘要&gt;</p>
<blockquote>
<p>人无远虑，必有近忧</p>
</blockquote>
<h3>前言</h3>
<p>在这个靠技术吃饭的年代，不多学一两门语言，还真的是很容易陷坑，最近分析了下编程语言，准备开始入<code>GO</code>这个坑，在花费了半天的时间后，终于搞定了环境的安装和<code>IDEA</code>的配置，这里我使用的是<code>IntelliJ IDEA 15</code>。</p>
<p>&lt;!-- more --&gt;</p>
<p>&lt;The rest of contents | 余下全文&gt;</p>
<h4>下载</h4>
<p>地址：<a href="https://golang.org/dl/" target="_blank" rel="external">SDK</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-3afe01ce3971a85e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h4>安装</h4>
<p>双击下载后的<code>dmg</code>进行安装，安装成功后，打开终端，输入下面命令查看是否安装成功
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go version</div></pre></td></tr></table></figure></p>
<p>如果显示<code>go version go1.8.1 darwin/amd64</code>那么恭喜你，安装成功。</p>
<h4>环境变量配置</h4>
<ol>
<li>
<p>打开终端，<code>cd ~</code>进入主目录</p>
</li>
<li>
<p><code>ls -all</code>查看所有文件，看是否存在<code>.bash_profile</code>文件</p>
</li>
<li>
<p>如果不存在，则执行<code>touch .bash_profile</code>新建</p>
</li>
<li>
<p>如果存在，则执行<code>vi .bash_profile</code>打开进行编辑</p>
<p>在文件中添加如下参数</p>
</li>
</ol>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export GOPATH=/Users/xxxxx/Go</div><div class="line">export GOBIN=$GOPATH/bin</div><div class="line">export PATH=$PATH:$GOBIN</div></pre></td></tr></table></figure></p>
<ol start="5">
<li>保存编辑，然后在执行<code>source ~/.bash_profile</code>，完成环境变量的配置</li>
<li><code>go env</code>查看我们配置成功后的环境变量</li>
</ol>
<p>说明：</p>
<p><code>GOPATH</code>：为我们开发常用的目录，建议不要和<code>Go</code>的安装目录一致，在该文件夹下又有三个文件夹：<code>src</code>、<code>pkg</code>、<code>bin</code> ，这里<code>src</code>我是自己新建的，<code>pkg</code>和<code>bin</code>是后面生成的。怎么生成的，后面会说到。</p>
<ol>
<li><code>src</code>：主要存放我们的源代码</li>
<li><code>bin</code>：存放编译后生成的可执行文件，可以自己执行</li>
<li><code>pkg</code>： 编译后生成的文件(<code>.a</code>文件)（非<code>main</code>函数的文件在<code>go install</code>后生成）</li>
</ol>
<p><code>GOBIN</code>：是<code>GOPATH</code>下的bin目录</p>
<p><code>PATH</code>：环境变量，需要<code>go-bin</code>目录加入到<code>path</code>路径下，生成可执行文件就可以直接运行了。</p>
<h4>示例</h4>
<p>通过终端进入我们配置好的路径<code>xxx\Go\src</code>中，新建一个文件夹<code>hellotest</code>（<code>mkdir hellotest</code>），新建一个<code>hello.go</code>（<code>vi hello.go</code>）文件，输入如下代码</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package hellotest</div><div class="line"></div><div class="line">func HelloTets(s string) string &#123;</div><div class="line">	return string(s)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存退出后，在当前路径执行<code>go install</code>，如果没有<code>pkg</code>文件夹，那么执行成功后，会在<code>xxx\Go</code>下面生成一个，并且生成一个<code>hellotest.a</code>文件，这就是我们的第一个库，感觉酷酷哒，那么怎么用呢？</p>
<p>下面我们在建一个<code>maintest</code>文件夹，然后新建一个<code>main.go</code>文件，在其中输入下面的内容</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;hellotest&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Printf(hellotest.HelloTets(&quot;你说我该怎么说呢&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并在当前文件夹中，执行下面的命令</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build</div></pre></td></tr></table></figure></p>
<p>这样，我们就成功调用了之前的库文件，并且你会发现在当前文件夹中多了一个可执行文件<code>maintest</code>没错，就是这样的一个执行文件。再执行下面的命令</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./maintest</div></pre></td></tr></table></figure></p>
<p>便会输出</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">你说我该怎么说呢</div></pre></td></tr></table></figure></p>
<p>再执行</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go install</div></pre></td></tr></table></figure></p>
<p>这时我们的执行文件就不再存在改文件中，而是转移到了<code>bin</code>文件夹中。
当然，我们也可以直接运行我们的<code>main.go</code>文件，如下</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go run main.go</div></pre></td></tr></table></figure></p>
<p>注：刚开始的小坑</p>
<ol>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
<li>大写字母开头的函数也是一样，相当于<code>class</code>中的带<code>public</code>关键词的公有函数；小写字母开头的就是有<code>private</code>关键词的私有函数</li>
</ol>
<h4>IntelliJ IDEA环境配置</h4>
<ol>
<li>
<p>打开<code>IntelliJ IDEA</code>,选择<code>IntelliJ IDEA--&gt;Preferences</code></p>
</li>
<li>
<p>如下图操作</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-0b15373e6bf52998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
</li>
<li>
<p>在弹出的界面，搜索<code>go</code>，然后选择<code>Go language</code>进行安装</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-df8d6e5b04f1b546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
</li>
<li>
<p>安装完成后，重新打开，你就可以进行新建工程了，如图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-9e65a67cdf42c488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
</li>
</ol>
<p>到此环境就基本配置OK</p>
<p>忙碌了一天了，要去办正事了，继续敲我的代码去了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS CoreImage之滤镜简单使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/12/iOS CoreImage之滤镜简单使用/" class="article-date">
      <time datetime="2017-05-11T16:00:00.000Z" itemprop="datePublished">2017-05-12</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/12/iOS CoreImage之滤镜简单使用/">iOS CoreImage之滤镜简单使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&lt;Excerpt in index | 首页摘要&gt;</p>
<blockquote>
<p>老骥伏枥，志在千里</p>
</blockquote>
<p>####前记</p>
<p>最近一直在研究图像处理方面，既上一篇<a href="http://www.jianshu.com/p/e7cad3da2a8b" target="_blank" rel="external">iOS Quart2D绘图之UIImage简单使用</a>后，就一直在学习关于<code>CoreImage</code>图像滤镜处理。中间也看了不少文章，也得到了不少帮助，下面就结合这些知识和我自己的认识，记录一下，方便自己，方便他人</p>
<ul>
<li>作用：对图像进行滤镜操作，比如模糊、颜色改变、锐化、人脸识别等。</li>
<li><code>Core Graphics</code>对比：基于<code>Quartz 2D</code>绘图引擎的绘图<code>API</code>，通过它可以进行绘图功能、常用的剪切裁剪合成等。</li>
</ul>
<p>&lt;!-- more --&gt;</p>
<p>&lt;The rest of contents | 余下全文&gt;</p>
<p>#####简介</p>
<p><code>Core Image</code>是一个很强大的框架。它可以让你简单地应用各种滤镜来处理图像，比如修改鲜艳程度, 色泽, 或者曝光。 它利用<code>GPU</code>（或者<code>CPU</code>）来非常快速、甚至实时地处理图像数据和视频的帧。并且隐藏了底层图形处理的所有细节，通过提供的API就能简单的使用了，无须关心<code>OpenGL</code>或者<code>OpenGL ES</code>是如何充分利用<code>GPU</code>的能力的，也不需要你知道<code>GCD</code>在其中发挥了怎样的作用，<code>Core Image</code>处理了全部的细节</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-c7902222e7ac3d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="大概方式.png"></p>
<p>#####实现方式</p>
<p><code>Core Image</code>滤镜需要一副输入图像（生成图像的滤镜除外）以及一些定制滤镜行为的参数。被请求时，<code>Core Image</code>将滤镜应用于输入图像，并提供一副输出图像。在应用滤镜方面，<code>Core Image</code>的效率极高：仅当输出图像被请求时才应用滤镜，而不是在指定时就应用它们；另外，<code>Core Image</code>尽可能将滤镜合并，以最大限度地减少应用滤镜的计算量。</p>
<p>#####涉及API</p>
<ul>
<li><code>CIImage</code>  ：这是一个模型对象，它保存能构建图像的数据，可以是图像的<code>Data</code>，可以是一个文件，也可以是<code>CIFilter</code>输出的对象。</li>
<li><code>CIContext</code> ：上下文，是框架真正工作的地方，它需要分配必要的内存，并编译和运行滤镜内核来执行图像处理。建立一个上下文是非常昂贵的，所以你会经常想创建一个反复使用的上下文。</li>
<li><code>CIFilter</code> ：滤镜对象，主要是对图像进行处理的类。通过设置一些键值来控制滤镜的具体效果</li>
</ul>
<hr>
<p>注：<code>Core Image</code>和<code>Core Graphics</code>使用的是左下原点坐标</p>
<p>到此有一个疑问？就是苹果怎么会弄出这么多<code>image</code>，比如<code>CIImage</code>、<code>UIImage</code>、<code>CGImageRef</code>，有什么区别呢？为了弄清这个问题，我也特别搜寻了一番，下面也记录一下</p>
<p>①<code>UIImage</code>：管理图片数据，主要用来展现，<code>Image</code>对象并没有提供直接访问相关的图片数据的操作, 因此你总是通过已经存在的图片数据来创建它</p>
<p>②<code>CGImage</code>：是基于像素的矩阵，每个点都对应了图片中点的像素信息</p>
<p>③<code>CIImage</code>：包含了创建图片的所有必要的数据，但其本身没有渲染成图片，它代表的是图像数据或者生成图像数据的流程（如滤镜）。拥有与之关联的图片数据, 但本质上并不是一张图片，你可以<code>CIImage</code>对象作为一个图片的&quot;配方&quot;。<code>CIImage</code>对象拥有生成一张图片所具备的所有信息，但<code>Core Image</code>并不会真正的去渲染一张图片, 除非被要求这么做。</p>
<hr>
<p>#####使用方式</p>
<ul>
<li>1 .  <code>CIImage</code>创建，在使用滤镜之前，你必须要先有一个<code>CIImage</code>对象，在拥有该对象后结合<code>CIFilter</code>才能实现我们的滤镜效果。这里需要注意的是，如果直接使用<code>image.cIImage</code>，那么很遗憾的告诉你，你将得到一个<code>nil</code>，哈哈
如下：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-6e86864a2a7eed2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.CIImage.png">
原因在<code>UIImage</code>的<code>API</code>中有介绍<code>// returns underlying CIImage or nil if CGImageRef based</code>，应该是说图片可能不是基于<code>CIImage</code>而创建的
正确的方式为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//得到CIImage</div><div class="line">CIImage *inputCIImage = [[CIImage alloc] initWithImage:_image];</div></pre></td></tr></table></figure></p>
<ul>
<li>2 .  <code>CIFilter</code>创建方式大概有下面三种</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+(nullable CIFilter *) filterWithName:(NSString *) name</div><div class="line">+(nullable CIFilter *)filterWithName:(NSString *)name</div><div class="line">                        keysAndValues:key0, ... NS_REQUIRES_NIL_TERMINATION NS_SWIFT_UNAVAILABLE(&quot;&quot;);</div><div class="line">+(nullable CIFilter *)filterWithName:(NSString *)name</div><div class="line">                  withInputParameters:(nullable NSDictionary&lt;NSString *,id&gt; *)params NS_AVAILABLE(10_10, 8_0);</div></pre></td></tr></table></figure></p>
<p>方法上都差不多，只是后面两个在初始化的时候加入了一些键值，在<code>API</code>文档中，可以查到很多键值，这里需要说明下，键值<code>kCIInputImageKey</code>是我们必须要设置的，这是为我们的滤镜对象设置输入图像，图像的值为<code>CIImage</code>对象，方法如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_filter setValue:inputCIImage forKey:kCIInputImageKey];</div></pre></td></tr></table></figure></p>
<p>方法中的<code>name</code>就是我们需要用的滤镜效果，具体效果，可以在官网上面进行查询，如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-122207ff8e1f7a2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter.png">
下面，我们以冲印效果为例，冲印属于<code>CICategoryColorEffect</code>中的<code>CIPhotoEffectProcess</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> //创建滤镜对象</div><div class="line">CIFilter *ciFilter = [CIFilter filterWithName:@&quot;CIPhotoEffectProcess&quot; keysAndValues:kCIInputImageKey,ciImage, nil];</div></pre></td></tr></table></figure></p>
<p>大概效果如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-67fa5eb8aaf2ac62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冲印.png"></p>
<hr>
<p>注意：
1、在设置键值的时候，我们需要有选择性的进行设置，具体怎么选择呢？
比如上面的冲印效果，在官方文档是这么展示的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-9a6508f9be3a1f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冲印展示.png">
只有一个必须输入的<code>inputImage</code>，因此不需要其它参数就可以实现
又比如高斯模糊<code>CIGaussianBlur</code>，在官方文档中，是这么展示的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-81315e96710d1a9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="高斯模糊展示.png">
如果我们需要控制其模糊半径，可以这么设置
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ciFilter setValue:@(20.f) forKey:@&quot;inputRadius&quot;];</div></pre></td></tr></table></figure></p>
<p>2、<code>CIFilter</code> 并不是线程安全的，这意味着 一个 <code>CIFilter</code>对象不能在多个线程间共享。如果你的操作是多线程的，每个线程都必须创建自己的 <code>CIFilter</code> 对象，而<code>CIContext</code>和<code>CIImage</code>对象都是不可修改的, 意味着它们可以在线程之间安全的共享。多个线程可以使用同样的<code>GPU</code>或者<code>CPU</code>的<code>CIContext</code>对象来渲染<code>CIImage</code>对象</p>
<p>在<code>CIFilter</code>类中，还有一些其他函数，可能是我们需要用到的，这里也简单说明下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//输入的键值信息</div><div class="line">NSArray&lt;NSString *&gt; *inputKeys;</div><div class="line">//输出的键值信息</div><div class="line">NSArray&lt;NSString *&gt; *outputKeys;</div><div class="line">//返回滤镜的属性描述信息</div><div class="line">NSDictionary&lt;NSString *,id&gt; *attributes;</div><div class="line">//将所有输入键值的值设为默认值（曾经乱用，导致我的滤镜效果完全没有任何反应，差点怀疑人生...）</div><div class="line">- (void)setDefaults;</div><div class="line">//根据滤镜的key查找其下面的所以子类效果</div><div class="line">+ (NSArray&lt;NSString *&gt; *)filterNamesInCategory:(nullable NSString *)category</div></pre></td></tr></table></figure></p>
<hr>
<ul>
<li>3 . <code>CIContext</code> 在创建结果图片的时候需要用到，刚开始用的时候，出于好奇用了两种不同的方法来返回结果，本以为....我会有一个方式获取不到处理后的结果，然而大跌眼镜，居然有....</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    CIImage *outPutImage = [ciFilter outputImage];</div><div class="line">    //获取上下文</div><div class="line">    CIContext *context = [CIContext contextWithOptions:nil];</div><div class="line">    </div><div class="line">    CGImageRef cgImage = [context createCGImage:outPutImage fromRect:outPutImage.extent];</div><div class="line">    </div><div class="line">    UIImage *filter_image = [UIImage imageWithCGImage:cgImage];</div><div class="line">    CGImageRelease(cgImage);</div><div class="line">    </div><div class="line">    </div><div class="line">//    UIImage *filter_image = [UIImage imageWithCIImage:outPutImage];</div></pre></td></tr></table></figure></p>
<p>就是上面屏蔽的代码部分<code>imageWithCIImage</code>，这就使我纳闷了，于是猜测并查阅资料，原来在调用该方法的时候，其实是隐式的声明了<code>CIContext</code>，这样看来，哇！好简单，省了我一堆代码，然而，这却引起另外的问题了，就是每次都会重新创建一个 <code>CIContext</code>，然而 <code>CIContext</code>的代价是非常高的。并且，<code>CIContext</code> 和 <code>CIImage</code> 对象是不可变的，在线程之间共享这些对象是安全的。所以多个线程可以使用同一个 <code>GPU</code> 或者 <code>CPU</code>
<code>CIContext</code>对象来渲染 <code>CIImage</code> 对象。所以我们不应该使用 <code>imageWithCIImage</code> 来生成<code>UIImage</code>，而应该用上述另外一种方式来获取结果图像。</p>
<p>#####Core Image 效率</p>
<p><code>Core Image</code>在处理图像的时候，可以有两种选择<code>GPU</code>、<code>CPU</code>，在<code>Context</code>中可以对其进行设置，通过设置键值，这里的键值为<code>kCIContextUseSoftwareRenderer</code>，默认情况下，是为<code>GPU</code>处理方式，如果将其设置为<code>YES</code>，则为<code>CPU</code>处理
如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//CPU处理</div><div class="line">CIContext *context = [CIContext contextWithOptions:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]];</div></pre></td></tr></table></figure></p>
<p>如果通过<code>GPU</code>的话，速度就会更快，利用了<code>GPU</code>硬件的并行优势，可以使用 <code>OpenGLES</code> 或者<code>Metal</code> 来渲染图像，这种方式<code>CPU</code>完全没有负担，应用程序的运行循环不会受到图像渲染的影响。但是也有个问题，就是如果<code>APP</code>运行到后台的时候，<code>GPU</code>就会停止处理，等回到前台的时候又继续，而如果采取<code>CPU</code>来处理的话，就不会出现这么一种情况，在前面的图中，我们可以看到<code>CPU</code>是采用<code>GCD</code>的方式来对图像进行渲染。所以在使用的时候，还是需要分情况，如果是处理复杂的操作，比如高斯模糊这样的，建议还是用<code>GPU</code>来处理，可以节省<code>CPU</code>的开销，如果在后台还需要操作的话，可以使用<code>CPU</code>来操作。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">CIImage *outPutImage = [ciFilter outputImage];</div><div class="line">//获取上下文</div><div class="line">CIContext *context = [CIContext contextWithOptions:nil];</div><div class="line"></div><div class="line">CGImageRef cgImage = [context createCGImage:outPutImage fromRect:outPutImage.extent];</div><div class="line"></div><div class="line">UIImage *filter_image = [UIImage imageWithCGImage:cgImage];</div><div class="line">CGImageRelease(cgImage);</div></pre></td></tr></table></figure></p>
<p>上面的这段代码是通过<code>GPU</code>的方式来处理图像，然后得到结果<code>UIImage</code>，最后再赋值给<code>UIImageView</code>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-bfce0c969605bc45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p>
<p>分析下这个过程：
1、将图像上传到<code>GPU</code>，然后进行滤镜处理
2、得到<code>CGImageRef cgImage</code>的时候，又将图像复制到了<code>CPU</code>上
3、在赋值给<code>UIImageView</code>进行显示的时候，又需要通过<code>GPU</code>处理位图数据，进行渲染
这样的话，我们就在<code>GPU</code>-<code>CPU</code>-<code>GPU</code>上循环操作，在性能上肯定是有一定的损耗的，那么为了避免这种问题，我们该这怎么办呢？
查看<code>API</code>，我们可以看到有这么一个函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (CIContext *)contextWithEAGLContext:(EAGLContext *)eaglContext</div></pre></td></tr></table></figure></p>
<p><code>EAGLContext</code>：是基于<code>OpenGL ES</code>的上下文
通过上面的函数，我们通过<code>OpenGL ES</code>的上下文创建的<code>Core Image</code>的上下文就可以实时渲染了，并且渲染图像的过程始终在 <code>GPU</code>上进行，但是要显示图像，又该怎么办呢？如果还是用<code>UIImageView</code>的话，那么势必会回到<code>CPU</code>上，这里，我们可以用<code>GLKView</code>，一个属于<code>GLKIT</code>中的类，通过<code>GLKView</code>和其属性<code>@property (nonatomic, retain) EAGLContext *context</code>来将图像绘制出来，这样的话，就能保证我们的滤镜，一直在<code>GPU</code>上进行，大大的提高效率。
针对该方案，我自定义了一个类似<code>UIImageView</code>的类<code>FilterImageView</code></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//FilterImageView.h</div><div class="line">#import &lt;GLKit/GLKit.h&gt;</div><div class="line"></div><div class="line">@interface FilterImageView : GLKView</div><div class="line"></div><div class="line">@property (nonatomic,strong) UIImage *image;</div><div class="line"></div><div class="line">@property (nonatomic,strong) CIFilter *filter;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><code>.m</code>文件核心代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//FilterImageView.m</div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</div><div class="line">    self = [super initWithFrame:frame context:context];</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        _ciContext = [CIContext contextWithEAGLContext:context options:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:NO] forKey:kCIContextUseSoftwareRenderer]];</div><div class="line">        //超出父视图 进行剪切</div><div class="line">        self.clipsToBounds = YES;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)drawRect:(CGRect)rect</div><div class="line">&#123;</div><div class="line">    if (_ciContext &amp;&amp; _image) &#123;</div><div class="line">        //得到CIImage</div><div class="line">        CIImage *inputCIImage = [[CIImage alloc] initWithImage:_image];</div><div class="line">        </div><div class="line">        CGRect inRect = [self imageBoundsForContentModeWithFromRect:inputCIImage.extent</div><div class="line">                                                             toRect:CGRectMake(0, 0, self.drawableWidth, self.drawableHeight)];</div><div class="line">        </div><div class="line">        if (_filter) &#123;</div><div class="line">            [_filter setValue:inputCIImage forKey:kCIInputImageKey];</div><div class="line">            //根据filter得到输出图像</div><div class="line">            if (_filter.outputImage) &#123;</div><div class="line">                //渲染开始</div><div class="line">                [_ciContext drawImage:_filter.outputImage</div><div class="line">                               inRect:inRect</div><div class="line">                             fromRect:inputCIImage.extent];</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">            [_ciContext drawImage:inputCIImage</div><div class="line">                           inRect:inRect</div><div class="line">                         fromRect:inputCIImage.extent];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如此之后，我们就能提高滤镜的效率，特别是一些复杂的。
关于滤镜，能写的就只要这么多了，在学习中，也确实发现这是一个好东西，可以做很多炫酷的东西出来，为此，特意做了一个简单的<a href="https://github.com/gao211326/UIImageProcessing" target="_blank" rel="external">Demo</a>，目前还未完善，希望各位勿喷。</p>
<p>参考文章</p>
<ul>
<li><a href="http://www.cocoachina.com/industry/20140812/9363.html" target="_blank" rel="external">iOS中图形图像处理第一部分:位图图像原图修改</a> 主要是讲解图像的基本原理和修改图像原理</li>
<li><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP30000136-SW29" target="_blank" rel="external">官方文档</a> 关于所有滤镜的效果展示和简单使用</li>
<li><a href="http://blog.csdn.net/zhangao0086/article/details/39012231" target="_blank" rel="external">swift讲解 CoreImage</a> 用swift讲解的关于滤镜的，讲的非常详细。</li>
<li><a href="http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">Core Image 你需要了解的那些事~</a> 讲的很详细的一篇</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS UIImage常用category" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/24/iOS UIImage常用category/" class="article-date">
      <time datetime="2017-04-23T16:00:00.000Z" itemprop="datePublished">2017-04-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/24/iOS UIImage常用category/">iOS Quart2D绘图之UIImage简单使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&lt;Excerpt in index | 首页摘要&gt;</p>
<blockquote>
<p>人生得意须尽欢，莫使金樽空对月。</p>
</blockquote>
<blockquote>
<p>天生我材必有用，千金散尽还复来。</p>
</blockquote>
<h4>前记</h4>
<p>说到<code>UIImage</code>大家都不会感到陌生，最近在研究<code>UIImage</code>，就顺便把之前工作中用到的一些<code>category</code>总结了一下，记录记录。</p>
<p>&lt;!-- more --&gt;</p>
<p>&lt;The rest of contents | 余下全文&gt;</p>
<p>在这之前先看一下一些简答的效果图</p>
<h5>1、简单处理</h5>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-98900569e5d83a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"></p>
<h5>2、GIF图片加载</h5>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-5a94c0273ad787dc.gif?imageMogr2/auto-orient/strip" alt="12.gif"></p>
<h5>3、图片添加文字、图片及图片截屏、擦除</h5>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-0bcc339da0b1e9fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加文字.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-21265f346636b586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加图片.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-c234216739195e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="截图.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-e5353c2f565c080f.gif?imageMogr2/auto-orient/strip" alt="wipe.gif"></p>
<h5>代码分析</h5>
<h6>1、图片圆角处理</h6>
<p>关于图片的圆角处理，这个可能用的比较多点，当然你也可以用给<code>UIIImageView</code>设置圆角来达到目的，但是在性能上特别是用在<code>tableview</code>上的时候，就没那么好了。</p>
<p>在这之前，我们先来看看<code>CGContextRef</code>，这个怎么解释呢？我的理解就是<code>画布</code>，就相当于我们在画画的时候的画板，我们需要画图片、文字、线条都需要在这上面进行。
在了解这个之后，我们就开始看代码</p>
<p>带圆圈的圆图</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">+ (UIImage*)gl_circleImage:(UIImage*)image withBorder:(CGFloat)border color:(UIColor *)color</div><div class="line">&#123;</div><div class="line">    //通过自己创建一个context来绘制,通常用于对图片的处理</div><div class="line">    //在retian屏幕上要使用这个函数，才能保证不失真</div><div class="line">    //该函数会自动创建一个context，并把它push到上下文栈顶，坐标系也经处理和UIKit的坐标系相同</div><div class="line">    UIGraphicsBeginImageContextWithOptions(CGSizeMake(image.size.width, image.size.height), NO, [UIScreen mainScreen].scale);</div><div class="line">    //获取上下文</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    CGRect rect = CGRectMake(0, 0, image.size.width, image.size.height);</div><div class="line">    //设置宽度</div><div class="line">    CGContextSetLineWidth(context, 4*border);</div><div class="line">    //设置边框颜色</div><div class="line">    CGContextSetStrokeColorWithColor(context, color.CGColor);</div><div class="line"></div><div class="line">    //画椭圆 当宽和高一样的时候 为圆 此处设置可视范围</div><div class="line">    CGContextAddEllipseInRect(context, rect);</div><div class="line">    //剪切可视范围</div><div class="line">    CGContextClip(context);</div><div class="line"></div><div class="line">    //绘制图片</div><div class="line">    [image drawInRect:rect];</div><div class="line"></div><div class="line">    CGContextAddEllipseInRect(context, rect);</div><div class="line">    // 绘制当前的路径 只描绘边框</div><div class="line">    CGContextStrokePath(context);</div><div class="line"></div><div class="line">    </div><div class="line">    UIImage *newimg = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    return newimg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本想讲点什么，但是代码中已经有注释，就不说什么了，这里需要注意的是<code>UIGraphicsBeginImageContextWithOptions</code>这个函数，最后一个参数--缩放因子，和我们平时用的倍图相关，比如<code>@x</code>,<code>@2x</code>,<code>@3x</code>，在<code>4s</code>上为<code>1</code>,后面的机型中，<code>plus</code>为<code>3</code>，其余为<code>2</code>，在这里可以设置为<code>0</code>，这样会自动匹配。</p>
<p>不带圆圈的圆图</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 创建圆形图片</div><div class="line"></div><div class="line"> @param image 原始图片</div><div class="line"> @return 返回</div><div class="line"> */</div><div class="line">+ (UIImage *)gl_circleImage:(UIImage *)image;</div></pre></td></tr></table></figure></p>
<p>由于和带圆圈的原图代码几乎一致，只是少了边框这部分代码，这里就不在贴出来了，后面会给出<code>demo</code></p>
<h6>2、根据颜色创建图片</h6>
<p>这个比较简单，最主要的是靠下面两个函数来进行实现</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//设置填充颜色</div><div class="line">CGContextSetFillColorWithColor(context, color.CGColor);</div><div class="line">//直接按rect的范围覆盖</div><div class="line">CGContextFillRect(context, CGRectMake(0, 0, size.width, size.height));</div></pre></td></tr></table></figure></p>
<p>在这里有两个函数，<code>CGContextSetFillColorWithColor</code>和<code>CGContextSetStrokeColorWithColor</code>，是相对的两个函数，一个是设置覆盖区域的颜色，一个是设置边框的颜色，在使用的时候应该和其他函数对应一起使用。
下面还是列出代码</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)gl_imageWithColor:(UIColor *)color size:(CGSize)size&#123;</div><div class="line">    CGSize imageSize = size;</div><div class="line">    //通过自己创建一个context来绘制，通常用于对图片的处理</div><div class="line">    UIGraphicsBeginImageContextWithOptions(imageSize, NO, [UIScreen mainScreen].scale);</div><div class="line">    //获取上下文</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    //设置填充颜色</div><div class="line">    CGContextSetFillColorWithColor(context, color.CGColor);</div><div class="line">    //直接按rect的范围覆盖</div><div class="line">    CGContextFillRect(context, CGRectMake(0, 0, size.width, size.height));</div><div class="line">    UIImage *newimg = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    return newimg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于根据颜色来绘制圆形图片代码和上面几乎一致，只是将其中的
<code>CGContextFillRect</code>换成了<code>CGContextAddEllipseInRect</code>和<code>CGContextFillPath</code>，这里就不在详细讲解</p>
<h6>3、给图片设置圆角</h6>
<p>这个可能用的比较多点，比如当美工不给我切图的时候，我们又需要使图片其中的几个角有圆角，那么这时候这个方法就派上用场了。</p>
<p>在这里，主要是通过方法<code>CGContextAddPath</code>和<code>UIBezierPath</code>一起来实现，详细看到这里，大家都知道怎么用的了，下面我们就来看源码</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">+ (UIImage*)gl_cornerImage:(UIImage*)image corner:(CGFloat)corner rectCorner:(UIRectCorner)rectCorner</div><div class="line">&#123;</div><div class="line">    CGSize imageSize = image.size;</div><div class="line">    UIGraphicsBeginImageContextWithOptions(imageSize, NO, [UIScreen mainScreen].scale);</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    CGRect rect = CGRectMake(0,</div><div class="line">                             0,</div><div class="line">                             imageSize.width,</div><div class="line">                             imageSize.height);</div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect</div><div class="line">                                               byRoundingCorners:rectCorner</div><div class="line">                                                     cornerRadii:CGSizeMake(corner,</div><div class="line">                                                                            corner)];</div><div class="line">    //添加路径</div><div class="line">    CGContextAddPath(context, [path CGPath]);</div><div class="line">    //剪切可视范围</div><div class="line">    CGContextClip(context);</div><div class="line">    [image drawInRect:rect];</div><div class="line">    </div><div class="line">    UIImage *newimg = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    return newimg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6>4、压缩图片</h6>
<p>说到压缩图片，这个应该是用的最多的了，比如有一天突然项目经理给你说，我们上传的这个图片啊，太大了，不仅浪费流量还特别慢，而且服务器压力还不小....你们客户端处理下把，最好在<code>250kb</code>左右，但是又不能裁剪图片，这个时候，这个方法就能大展身手了。
其主要思路是通过一个<code>while</code>循环，不停的去缩小我们所要的图片，当然计算图片的大小，我们用的是<code>UIImageJPEGRepresentation</code>，虽然这个和真实图片的大小还是有那么点误差，但是一般情况下还是没什么问题的，下面我们来看源码</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">+ (UIImage*)gl_compressImage:(UIImage *)image maxSize:(CGFloat)maxSize maxSizeWithKB:(CGFloat)maxSizeKB</div><div class="line">&#123;    </div><div class="line">    if (maxSize &lt;= 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (maxSizeKB &lt;= 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CGSize compressSize = image.size;</div><div class="line">    //获取缩放比 进行比较 </div><div class="line">    CGFloat widthScale = compressSize.width*1.0 / maxSize;</div><div class="line">    CGFloat heightScale = compressSize.height*1.0 / maxSize;</div><div class="line">    </div><div class="line">    if (widthScale &gt; 1 &amp;&amp; widthScale &gt; heightScale) &#123;</div><div class="line">        compressSize = CGSizeMake(image.size.width/widthScale, image.size.height/widthScale);</div><div class="line">    &#125;</div><div class="line">    else if (heightScale &gt; 1 &amp;&amp; heightScale &gt; widthScale)&#123;</div><div class="line">        compressSize = CGSizeMake(image.size.width/heightScale, image.size.height/heightScale);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //创建图片上下文 并获取剪切尺寸后的图片</div><div class="line">    UIGraphicsBeginImageContextWithOptions(compressSize, NO, 1);</div><div class="line">    CGRect rect = &#123;CGPointZero,compressSize&#125;;</div><div class="line">    [image drawInRect:rect];</div><div class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    </div><div class="line">    //循环缩小图片大小</div><div class="line">    NSData *imageData = UIImageJPEGRepresentation(newImage, 1.0);</div><div class="line">    //获取当前图片的大小</div><div class="line">    CGFloat currentImageSizeOfKB = imageData.length/1024.0;</div><div class="line">    </div><div class="line">    //压缩比例</div><div class="line">    CGFloat compress = 0.9;</div><div class="line">    </div><div class="line">    while (currentImageSizeOfKB &gt; maxSizeKB &amp;&amp; compress &gt; 0.1) &#123;</div><div class="line">        imageData = UIImageJPEGRepresentation(newImage, compress);</div><div class="line">        currentImageSizeOfKB = imageData.length/1024.0;</div><div class="line">        compress -= 0.1;</div><div class="line">    &#125;</div><div class="line">    return [UIImage imageWithData:imageData];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6>5、加载GIF图片</h6>
<p>说到加载动态图片，需求量虽然不大，但还是偶尔会用到，这里我们有一个很关键的<code>API</code>---<code>+ (nullable UIImage *)animatedImageWithImages:(NSArray&lt;UIImage *&gt; *)images duration:(NSTimeInterval)duration</code>，通过这个函数，我们可以简单的来播放动态图片。下面我们要做的就是怎么得到<code>GIF</code>图片的图片资源和其播放时间<code>duration</code>。</p>
<p>关于图片源，在<code>ImageIo</code>中有这么一个类<code>CGImageSource</code>，其中的<code>CGImageSourceRef</code>也就是我们所说的图片源，查看API，我们可以得到三种方式:</p>
<p>1、<code>CGImageSourceCreateWithURL</code>
基于一个URL链接来读取图片信息。这个方法也是苹果推荐的方法，因为有些时候我们想获取照片的信息，但不需要将照片加载到内存中（因为这是没必要的），所以只需要给出照片的URL地址。
2、<code>CGImageSourceCreateWithData</code>
这个方法是基于一个NSData对象来获取照片信息。所以如果想使用此方法，必需将一个UIImage对象转换成NSData对象，例如：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *filePath = [[NSBundle mainBundle]pathForResource:@&quot;24&quot; ofType:@&quot;jpg&quot;];</div><div class="line">NSData *data = [NSData dataWithContentsOfFile:filePath];</div><div class="line">CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)data, nil);</div></pre></td></tr></table></figure></p>
<p>3、<code>CGImageSourceCreateWithDataProvider</code>
这种方法主要是需要将一个<code>CGImageRef</code>生成一个<code>CGDataProvider</code>。而参数<code>&quot;options&quot;</code>选项是一个字典，用于创建图片源时提供的附加属性，例如是否对图片进行缓存等。</p>
<p>在有了得到图片源的方法后，我们就可以通过图片源来得到其中的相关信息，最主要的是动画时间，具体代码如下</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">static CGFloat frameDuration(NSInteger index,CGImageSourceRef source)</div><div class="line">&#123;</div><div class="line">    //获取每一帧的信息</div><div class="line">    CFDictionaryRef frameProperties = CGImageSourceCopyPropertiesAtIndex(source,index, nil);</div><div class="line">    //转换为dic</div><div class="line">    NSDictionary *framePropertiesDic = (__bridge NSDictionary *)frameProperties;</div><div class="line">    //获取每帧中关于GIF的信息</div><div class="line">    NSDictionary *gifProperties = framePropertiesDic[(__bridge NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">    /*</div><div class="line">     苹果官方文档中的说明</div><div class="line">     kCGImagePropertyGIFDelayTime</div><div class="line">     The amount of time, in seconds, to wait before displaying the next image in an animated sequence</div><div class="line">     </div><div class="line">     kCGImagePropertyGIFUnclampedDelayTime</div><div class="line">     The amount of time, in seconds, to wait before displaying the next image in an animated sequence. This value may be 0 milliseconds or higher. Unlike the kCGImagePropertyGIFDelayTime property, this value is not clamped at the low end of the range.</div><div class="line">     </div><div class="line">     看了翻译瞬间蒙了 感觉一样 但是kCGImagePropertyGIFDelayTime 可能为0  所以我觉得可以先判断kCGImagePropertyGIFDelayTime</div><div class="line">     */</div><div class="line">    CGFloat duration = 0.1;</div><div class="line">    </div><div class="line">    NSNumber *unclampedPropdelayTime = gifProperties[(__bridge NSString *)kCGImagePropertyGIFUnclampedDelayTime];</div><div class="line">    NSNumber *delayTime = gifProperties[(__bridge NSString *)kCGImagePropertyGIFDelayTime];</div><div class="line">    </div><div class="line">    if (unclampedPropdelayTime) &#123;</div><div class="line">        duration = unclampedPropdelayTime.floatValue;</div><div class="line">    &#125;else&#123;</div><div class="line">        if (delayTime) &#123;</div><div class="line">            duration = delayTime.floatValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(frameProperties);</div><div class="line">    </div><div class="line">    return duration;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在有了动态图片时间后，我们来看看后续动态图片的实现</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//动态图片处理</div><div class="line">static UIImage *animatedImageWithAnimateImageSource(CGImageSourceRef imageSource)</div><div class="line">&#123;</div><div class="line">    if (imageSource) &#123;</div><div class="line">        //得到图片资源的数量</div><div class="line">        size_t imageCount = CGImageSourceGetCount(imageSource);</div><div class="line">        </div><div class="line">        //最终图片资源</div><div class="line">        UIImage *resultImage = nil;</div><div class="line">        </div><div class="line">        //动态图片时间</div><div class="line">        NSTimeInterval duration = 0.0;</div><div class="line">        //取图片资源</div><div class="line">        NSMutableArray *images = [NSMutableArray arrayWithCapacity:imageCount];</div><div class="line">        </div><div class="line">        for (size_t i = 0; i &lt; imageCount; i ++) &#123;</div><div class="line">            //此处用到了create  后面记得释放</div><div class="line">            CGImageRef cgImage = CGImageSourceCreateImageAtIndex(imageSource, i, NULL);</div><div class="line">            </div><div class="line">            if (cgImage) &#123;</div><div class="line">                //将图片加入到数组中</div><div class="line">                [images addObject:[UIImage imageWithCGImage:cgImage scale:[UIScreen mainScreen].scale orientation:UIImageOrientationUp]];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            duration += frameDuration(i, imageSource);</div><div class="line">            </div><div class="line">            //释放掉 不然会内存泄漏</div><div class="line">            CGImageRelease(cgImage);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (duration == 0.0) &#123;</div><div class="line">            duration = 0.1 * imageCount;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        resultImage = [UIImage animatedImageWithImages:images duration:duration];</div><div class="line">        </div><div class="line">        CFRelease(imageSource);</div><div class="line">        </div><div class="line">        return resultImage;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的话，我们就可以加载我们所需要的动态图片了。在上述代码中，需要注意的几个地方
1、使用了<code>create和copy</code>这样的函数，我们需要手动对其内存进行管理
2、在封装方法的时候，我只封装了用图片<code>url</code>和图片二进制文件以及图片资源地址的方法，需要注意的是，在使用图片二进制文件的时候，需要特别注意二进制文件的转化，不能使用<code>UIImageJPEGRepresentation</code>，亲测不对，不知道<code>gif</code>用此方法为什么不行，建议通过路径的方式来获取<code>data</code>，如<code>NSData *data = [NSData dataWithContentsOfFile:imagePath]</code>，上面是核心代码，其他部分，可以参考后面的<code>demo</code></p>
<h6>6、图片添加文字或者图片</h6>
<p>这个比较简单，最主要的方法就是通过<code>drawInRect</code>来将文字或者图片画到当前的画布上，这里就只列一个添加文字的代码出来，添加图片的后面可以参考<code>demo</code></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)gl_addTitleAboveImage:(UIImage *)image addTitleText:(NSString *)text</div><div class="line">                   attributeDic:(NSDictionary *)attributeDic point:(CGPoint)point</div><div class="line">&#123;</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, [UIScreen mainScreen].scale);</div><div class="line">    </div><div class="line">    CGRect imageRect = CGRectMake(0, 0, image.size.width, image.size.height);</div><div class="line">    </div><div class="line">    [image drawInRect:imageRect];</div><div class="line">    </div><div class="line">    [text drawAtPoint:point withAttributes:attributeDic];</div><div class="line">    </div><div class="line">    //获取上下文中的新图片</div><div class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    </div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    </div><div class="line">    return newImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是函数<code>UIGraphicsBeginImageContextWithOptions</code>中的最后一个参数，需要根据当前屏幕来，否则添加的文字和图片可能会出现模糊，如在<code>5S</code>上面，将其设为<code>1</code>。</p>
<h6>7、图片截屏或者擦除</h6>
<p>在这两个功能中，最主要用到的函数是<code>renderInContext</code>和<code>CGContextClearRect</code>，第一个主要是用来截屏用的，渲染当前图片，与之接近的还有一个函数<code>drawInContext</code>，当然，我们不能用这个函数，因为这个函数不能渲染图片，只针对layer。而后面的一个函数主要是用来清除该区域的。通过上面两个函数，我们就能够轻松的实现擦除功能，就如橡皮擦功能。
代码如下</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)gl_wipeImageWithView:(UIView *)view movePoint:(CGPoint)point brushSize:(CGSize)size</div><div class="line">&#123;</div><div class="line">    //开启上下文</div><div class="line">    UIGraphicsBeginImageContext(view.bounds.size);</div><div class="line">    </div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    //此方法不能渲染图片 只针对layer</div><div class="line">    //[view.layer drawInContext:context];</div><div class="line">    </div><div class="line">    //以point为中心，然后size的一半向两边延伸  坐画笔  橡皮擦</div><div class="line">    CGRect clearRect = CGRectMake(point.x - size.width/2.0, point.y - size.width/2.0, size.width, size.height);</div><div class="line">    </div><div class="line">    //渲染图片</div><div class="line">    [view.layer renderInContext:context];</div><div class="line">    //清除该区域</div><div class="line">    CGContextClearRect(context, clearRect);</div><div class="line">    //得到新图片</div><div class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    </div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //避免内存泄漏</div><div class="line">    view.layer.contents = nil;</div><div class="line">    </div><div class="line">    return newImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>移动路径的代码就不在这里贴了，<code>demo</code>中有的，截屏的核心代码也就不贴了，很简单的，可以查看<code>demo</code>。</p>
<h5>写在最后</h5>
<p>其实上面的这些都是比较简单的，主要是通过<code>CGContextRef</code>及其中的一些方法进行实习的，真正让人东西的，还是图形的处理，如添加马赛克、图片滤镜等，今天面试就问道了滤镜，当场就蒙了，后面我会努力研究下，希望到时候也能有好的东西分享给大家。
下面附上<a href="https://github.com/gao211326/UIImageOperationDemo" target="_blank" rel="external">demo</a>地址，如果觉得还可以，可以给个<code>star</code>哦，不甚感激~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS自定义转场动画" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/05/iOS自定义转场动画/" class="article-date">
      <time datetime="2017-04-04T16:00:00.000Z" itemprop="datePublished">2017-04-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/05/iOS自定义转场动画/">iOS 自定义转场动画浅谈</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&lt;Excerpt in index | 首页摘要&gt;</p>
<blockquote>
<p>路漫漫其修远兮，吾将上下而求索</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-3de3520ec46cfa0a.gif?imageMogr2/auto-orient/strip" alt="kaipingtu.gif"></p>
<p>####前记</p>
<p>想研究自定义转场动画很久了，时间就像海绵，挤一挤还是有的，花了差不多有10天的时间，终于对转场动画了解了一点。自从<code>iOS 7</code>以后，我们就可以自定义转场动画，实现我们想要的效果，在这之前，我们先来看一张图，大概了解下，需要知道些什么</p>
<p>&lt;!-- more --&gt;</p>
<p>&lt;The rest of contents | 余下全文&gt;</p>
<p><code>相关类联系图</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-9562ad05ab50db6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>相信各位看官也差不多看完这张图了，下面我们就来简单了解下其中的类和相关的函数</p>
<p>说到转场动画，其实无非就是我们常用的<code>push</code> <code>pop</code> <code>present</code> <code>dismiss</code>四种动画，其中前面两个是成对使用，后面两个成对使用，我们先看看<code>push</code>这组在自定义转场动画中所涉及到的类</p>
<p>由于<code>push</code>动画组需要配合<code>navigationController</code>来使用，所以上图中的<code>UINavigationControllerDelegate</code>肯定是我们需要的类</p>
<p>#####UINavigationControllerDelegate</p>
<p>先来看看其中需要用到的函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController NS_AVAILABLE_IOS(7_0);</div><div class="line"></div><div class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC  NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure></p>
<p>第一个函数的返回值是一个<code>id &lt;UIViewControllerInteractiveTransitioning&gt;</code>值
第二个函数返回的值是一个<code>id &lt;UIViewControllerAnimatedTransitioning&gt;</code>值
那么我们就先从这两个返回值入手，来看下两个函数的作用</p>
<p>#####UIViewControllerInteractiveTransitioning 、UIPercentDrivenInteractiveTransition</p>
<p>这两个类又是干什么的呢？<code>UIPercentDrivenInteractiveTransition</code>遵守协议<code>UIViewControllerInteractiveTransitioning</code>,通过查阅资料了解到，<code>UIPercentDrivenInteractiveTransition</code>这个类的对象会根据我们的手势，来决定我们的自定义过渡的完成度，也就是这两个其实是和手势交互相关联的，自然而然我们就想到了<code>iOS 7</code>引进的侧滑手势，对，就是侧滑手势，说到这里，我就顺带介绍一个类，<code>UIScreenEdgePanGestureRecognizer</code>，手势侧滑的类，具体怎么使用，后面我会陆续讲到。</p>
<p>涉及函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//更新进度</div><div class="line">- (void)updateInteractiveTransition:(CGFloat)percentComplete;</div><div class="line">//取消转场 回到转场前的效果</div><div class="line">- (void)cancelInteractiveTransition;</div><div class="line">//完成转场 </div><div class="line">- (void)finishInteractiveTransition;</div></pre></td></tr></table></figure></p>
<p>#####UIViewControllerAnimatedTransitioning</p>
<p>在这个类中，我们又看到了两个函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//转场时间</div><div class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div><div class="line"></div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div></pre></td></tr></table></figure></p>
<p>其中又涉及到一个新的类<code>UIViewControllerContextTransitioning</code>，那么这个又是干什么的呢？我们等下再来了解，先来谈谈第一个函数<code>transitionDuration</code>，从返回值我们可以猜测出这是和时间有关的，没错，这就是我们自定义转场动画所需要的时间
那么下面我们就来看看<code>UIViewControllerContextTransitioning</code></p>
<p>#####UIViewControllerContextTransitioning</p>
<p>这个类就是我们自定义转场动画所需要的核心，即转场动画的上下文，定义了转场时需要的元素，比如在转场过程中所参与的视图控制器和视图的相关属性
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//转场动画的容器</div><div class="line">@property(nonatomic, readonly) UIView *containerView;</div><div class="line">//通过对应的`key`可以得到我们需要的`vc`</div><div class="line">- (UIViewController *)viewControllerForKey:(UITransitionContextViewControllerKey)key</div><div class="line">//转场动画完成时候调用，必须调用，否则在进行其他转场没有任何效果</div><div class="line">- (void)completeTransition:(BOOL)didComplete</div></pre></td></tr></table></figure></p>
<p>看到这里，我们现在再去看<code>UINavigationControllerDelegate</code>中的两个函数和<code>UIViewControllerAnimatedTransitioning</code>中的<code>animateTransition</code>函数，就能完全理解了</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//主要用于手势交互转场 for push or pop</div><div class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController NS_AVAILABLE_IOS(7_0);</div><div class="line"></div><div class="line">//非手势交互转场 for push or pop</div><div class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC  NS_AVAILABLE_IOS(7_0);</div><div class="line"></div><div class="line">//实现转场动画 通过transitionContext</div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div></pre></td></tr></table></figure></p>
<p>到此，我们还有一个类没有了解，那就是<code>UIViewControllerTransitioningDelegate</code>有了前面的分析，我们可以很好的理解</p>
<p>#####UIViewControllerTransitioningDelegate</p>
<p>主要是针对<code>present</code>和<code>dismiss</code>动画的转场
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//非手势转场交互 for present</div><div class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</div><div class="line">//非手势转场交互 for dismiss</div><div class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed</div><div class="line">//手势交互 for dismiss</div><div class="line">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator</div><div class="line">//手势交互 for present</div><div class="line">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator</div></pre></td></tr></table></figure></p>
<p>基本定义和概览我们差不多应该有了一定的了解，正如上图中的简单描述。</p>
<p>了解性的东西说了这么多，下面我们就来点实际性的东西，除了第一张开门那种自定义动画，再来几个比较常用的动画</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-b29e25db7cba47cd.gif?imageMogr2/auto-orient/strip" alt="CircleSpread.gif"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-cd46b09ac54ba40a.gif?imageMogr2/auto-orient/strip" alt="circleRectSpread.gif"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-ebef7ba6c2fabc04.gif?imageMogr2/auto-orient/strip" alt="page.gif"></p>
<p>这些动画都比较简单，相信许多大神都很清楚，还望见谅，下面我就对每一种进行分析分析，在分析动画之前，先来看看怎么将上面的各个类进行封装起来，使用更方便，这里不得不感谢很久之前看到的一篇文章，从他的<a href="http://www.cocoachina.com/ios/20160629/16856.html" target="_blank" rel="external">文章</a>中收获非常大。</p>
<p>在学习转场动画的时候，虽然对所有类的关系有了一定了解，但是封装的时候，完全没有想到还有这么好的思路，确实是学习了。下面我们就一起来看看封装思路。</p>
<p>####封装思路</p>
<p>#####1. 新建一个综合管理转场动画的类</p>
<p>作用：主要是管理转场所需要的一些设置，诸如转场时间和转场的实现（主要是在子类中进行实现，分离开来），用户在自定义转场动画的时候，只需要继承该类并重写父类方法就可以
类名：<code>GLTransitionManager</code>，需要准守的协议有<code>&lt;UINavigationControllerDelegate,UIViewControllerTransitioningDelegate&gt;</code>
通过这样，就可以将<code>present</code>和<code>push</code>动画相关的操作在该类中进行管理
<code>GLTransitionManager.h</code>中具体方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface GLTransitionManager : NSObject&lt;UINavigationControllerDelegate,UIViewControllerTransitioningDelegate&gt;</div><div class="line"></div><div class="line">/**</div><div class="line"> 转场动画的时间 默认为0.5s</div><div class="line"> */</div><div class="line">@property (nonatomic,assign) NSTimeInterval duration;</div><div class="line"></div><div class="line">/**</div><div class="line"> 入场动画 </div><div class="line"> </div><div class="line"> @param contextTransition 实现动画</div><div class="line"> */</div><div class="line">- (void)setToAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)contextTransition;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> 退场动画</div><div class="line"> </div><div class="line"> @param contextTransition 实现动画</div><div class="line"> */</div><div class="line">- (void)setBackAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)contextTransition;</div></pre></td></tr></table></figure></p>
<p>相信大家也看到了在入场和退场动画中都有<code>(id&lt;UIViewControllerContextTransitioning&gt;) contextTransition</code>这么一个参数，通过该参数，我们可以获取转场动画的相关<code>vc</code>和其他信息，进行转场动画的实现，即我们在自定义转场动画的时候，只需要重写该两个方法就可以，通过<code>contextTransition</code>来实现动画，而<code>&lt;UIViewControllerContextTransitioning&gt;</code>又在<code>UIViewControllerAnimatedTransitioning</code>协议的方法<code>- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</code>中涉及到，于是我又新建了一个准守协议<code>UIViewControllerAnimatedTransitioning</code>的类<code>GLTransitionAnimation</code>，也就是下面我们将的类</p>
<p>#####2.转场动画配置及实现类</p>
<p>作用：虽然是配置和实现类，但是在该类中并没有进行实现，这里也正是之前那个博主的高明之处，至少我是这么认为的。在该类中，我们用<code>block</code>的传值方法将其传入到我们的管理类中，也就是<code>GLTransitionManager</code></p>
<p><code>GLTransitionAnimation.h</code>文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> GLTransitionAnimation 块</div><div class="line"></div><div class="line"> @param contextTransition 将满足UIViewControllerContextTransitioning协议的对象传到管理内 在管理类对动画统一实现</div><div class="line"> */</div><div class="line">typedef void(^GLTransitionAnimationBlock)(id &lt;UIViewControllerContextTransitioning&gt; contextTransition);</div><div class="line"></div><div class="line">@interface GLTransitionAnimation : NSObject&lt;UIViewControllerAnimatedTransitioning&gt;</div><div class="line"></div><div class="line">@property (nonatomic,copy) GLTransitionAnimationBlock animationBlock;</div><div class="line"></div><div class="line">/**</div><div class="line"> 初始化方法</div><div class="line"></div><div class="line"> @param duration 转场时间</div><div class="line"> @return 返回</div><div class="line"> */</div><div class="line">- (id)initWithDuration:(NSTimeInterval)duration;</div></pre></td></tr></table></figure></p>
<p><code>GLTransitionAnimation.m</code>文件比较简单，这里就先不详说，我们先回到管理类中，来看看怎么使用</p>
<p><code>GLTransitionManager.m</code>文件，
在此种定义两个属性
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 入场动画</div><div class="line"> */</div><div class="line">@property (nonatomic,strong) GLTransitionAnimation *toTransitionAnimation;</div><div class="line"></div><div class="line">/**</div><div class="line"> 退场动画</div><div class="line"> */</div><div class="line">@property (nonatomic,strong) GLTransitionAnimation *backTransitionAnimation;</div></pre></td></tr></table></figure></p>
<p>实现方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#pragma mark == 懒加载</div><div class="line">- (GLTransitionAnimation *)toTransitionAnimation</div><div class="line">&#123;</div><div class="line">    if (nil == _toTransitionAnimation) &#123;</div><div class="line">        __weak typeof(self) weakSelf = self;</div><div class="line">        _toTransitionAnimation = [[GLTransitionAnimation alloc] initWithDuration:self.duration ];</div><div class="line">        _toTransitionAnimation.animationBlock = ^(id&lt;UIViewControllerContextTransitioning&gt; contextTransition)</div><div class="line">        &#123;</div><div class="line">            [weakSelf setToAnimation:contextTransition];</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return _toTransitionAnimation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (GLTransitionAnimation *)backTransitionAnimation</div><div class="line">&#123;</div><div class="line">    if (nil == _backTransitionAnimation) &#123;</div><div class="line">        __weak typeof(self) weakSelf = self;</div><div class="line">        _backTransitionAnimation = [[GLTransitionAnimation alloc] initWithDuration:self.duration];</div><div class="line">        _backTransitionAnimation.animationBlock = ^(id&lt;UIViewControllerContextTransitioning&gt; contextTransition)</div><div class="line">        &#123;</div><div class="line">            [weakSelf setBackAnimation:contextTransition];</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return _backTransitionAnimation;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面这一方法，我们就很好的将关键参数和对外接口联系起来了。这样我们就只需要在<code>setToAnimation</code>和<code>setBackAnimation</code>进行转场动画的具体实现即可。
当然这里还有一个小问题，相信各位也发现了，就是为什么将属性定义在了<code>.m</code>文件里呢？是的，这里确实是定义在了<code>.m</code>文件中，其实就是为了更少的暴露不需要的。</p>
<p>搞定这个之后，我们在来看看，在上面时候，调用该属性呢？
下面我们就来看具体使用的地方
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//非手势转场交互 for present</div><div class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source&#123;</div><div class="line">    return self.toTransitionAnimation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//非手势转场交互 for dismiss</div><div class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed&#123;</div><div class="line">    return self.backTransitionAnimation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//================</div><div class="line">//非手势转场交互 for push or pop</div><div class="line">/*****注释:通过 fromVC 和 toVC 我们可以在此设置需要自定义动画的类 *****/</div><div class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC</div><div class="line">&#123;</div><div class="line">    _operation = operation;</div><div class="line">    </div><div class="line">    if (operation == UINavigationControllerOperationPush)</div><div class="line">    &#123;</div><div class="line">        return self.toTransitionAnimation;</div><div class="line">    &#125;</div><div class="line">    else if (operation == UINavigationControllerOperationPop)</div><div class="line">    &#123;</div><div class="line">        return self.backTransitionAnimation;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这两个地方使用后，我们差不多就完成了一半了，那还一部分呢？那就是我们的手势滑动，下面我们就来看看手势滑动。</p>
<p>#####3.手势交互管理类</p>
<p>作用：主要通过侧滑手势来管理交互，在iOS 7后引入新的类<code>UIPercentDrivenInteractiveTransition</code>，该类的对象会根据我们的手势，来决定我们的自定义过渡的完成度，所以此次我采用继承的方式，然后在继承的类中加入滑动手势类，这里加入的是侧滑手势类<code>UIScreenEdgePanGestureRecognizer</code>，这个类也就是我定义的<code>GLInteractiveTransition</code>类</p>
<p><code>GLInteractiveTransition.h</code>文件</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> 手势的方向枚举</div><div class="line"></div><div class="line"> - GLPanEdgeTop:屏幕上方</div><div class="line"> - GLPanEdgeLeft:屏幕左侧</div><div class="line"> - GLPanEdgeBottom: 屏幕下方</div><div class="line"> - GLPanEdgeRight: 屏幕右方</div><div class="line"> */</div><div class="line">typedef NS_ENUM(NSInteger,GLEdgePanGestureDirection) &#123;</div><div class="line">    GLPanEdgeTop    = 0,</div><div class="line">    GLPanEdgeLeft,</div><div class="line">    GLPanEdgeBottom,</div><div class="line">    GLPanEdgeRight</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">///**</div><div class="line">// 手势转场类型</div><div class="line">//</div><div class="line">// - GLInteractiveTransitionPush: push</div><div class="line">// - GLInteractiveTransitionPop: pop</div><div class="line">// - GLInteractiveTransitionPresent: present</div><div class="line">// - GLInteractiveTransitionDismiss: dismiss</div><div class="line">// */</div><div class="line">//typedef NS_ENUM(NSInteger,GLInteractiveTransitionType) &#123;</div><div class="line">//    GLInteractiveTransitionPush = 0,</div><div class="line">//    GLInteractiveTransitionPop,</div><div class="line">//    GLInteractiveTransitionPresent ,</div><div class="line">//    GLInteractiveTransitionDismiss</div><div class="line">//&#125;;</div><div class="line"></div><div class="line"></div><div class="line">@interface GLInteractiveTransition : UIPercentDrivenInteractiveTransition</div><div class="line"></div><div class="line">/**</div><div class="line"> 是否满足侧滑手势交互</div><div class="line"> */</div><div class="line">@property (nonatomic,assign) BOOL isPanGestureInteration;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> 转场时的操作 不用传参数的block</div><div class="line"> */</div><div class="line">@property (nonatomic,copy) dispatch_block_t eventBlcok;</div><div class="line"></div><div class="line">/**</div><div class="line"> 添加侧滑手势</div><div class="line"></div><div class="line"> @param view 添加手势的view</div><div class="line"> @param direction 手势的方向</div><div class="line"> */</div><div class="line">- (void)addEdgePageGestureWithView:(UIView *)view direction:(GLEdgePanGestureDirection)direction;</div></pre></td></tr></table></figure></p>
<p>在<code>.h</code>文件中，定义了两个属性，一个是用来判断是否需满足侧滑手势，这个在后面会讲到。另一个是用来在侧滑的时候执行所需要的转场的<code>block</code>，之前本来是没有加这个的，但是在后面使用的时候，由于想加侧滑的<code>present</code>和<code>push</code>效果，所以就加了一个。</p>
<p>下面看看<code>.m</code>文件滑动手势中的具体实现
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">- (void)handlePopRecognizer:(UIPanGestureRecognizer*)recognizer &#123;</div><div class="line">    // 计算用户手指划了多远</div><div class="line">    </div><div class="line">    CGFloat progress = fabs([recognizer translationInView:self.gestureView].x) / (self.gestureView.bounds.size.width * 1.0);</div><div class="line">    progress = MIN(1.0, MAX(0.0, progress));</div><div class="line">        </div><div class="line">    switch (recognizer.state) &#123;</div><div class="line">        case UIGestureRecognizerStateBegan:</div><div class="line">        &#123;</div><div class="line">            _isPanGestureInteration = YES;</div><div class="line">            </div><div class="line">            if (self.eventBlcok) &#123;</div><div class="line">                self.eventBlcok();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // 创建过渡对象，弹出viewController</div><div class="line">//            </div><div class="line">//            UIViewController *fromVc = [self gl_viewController];</div><div class="line">//            </div><div class="line">//            switch (self.transitionType) &#123;</div><div class="line">//                case GLInteractiveTransitionPush:</div><div class="line">//                &#123;</div><div class="line">//                    </div><div class="line">//                &#125;</div><div class="line">//                    break;</div><div class="line">//                case GLInteractiveTransitionPop:</div><div class="line">//                &#123;</div><div class="line">//                    if (fromVc.navigationController) &#123;</div><div class="line">//                        [fromVc.navigationController popViewControllerAnimated:YES];</div><div class="line">//                    &#125;</div><div class="line">//                &#125;</div><div class="line">//                    break;</div><div class="line">//                case GLInteractiveTransitionPresent:</div><div class="line">//                &#123;</div><div class="line">//                    </div><div class="line">//                &#125;</div><div class="line">//                    break;</div><div class="line">//                case GLInteractiveTransitionDismiss:</div><div class="line">//                &#123;</div><div class="line">//                    [fromVc dismissViewControllerAnimated:YES completion:nil];</div><div class="line">//                &#125;</div><div class="line">//                    break;</div><div class="line">//                default:</div><div class="line">//                    break;</div><div class="line">//            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case UIGestureRecognizerStateChanged:</div><div class="line">        &#123;</div><div class="line">            // 更新 interactive transition 的进度</div><div class="line">            [self updateInteractiveTransition:progress];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case UIGestureRecognizerStateEnded:</div><div class="line">        case UIGestureRecognizerStateCancelled:</div><div class="line">        &#123;</div><div class="line">//            NSLog(@&quot; 打印信息:%f&quot;,progress);</div><div class="line">            // 完成或者取消过渡</div><div class="line">            if (progress &gt; 0.5) &#123;</div><div class="line">                [self finishInteractiveTransition];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                [self cancelInteractiveTransition];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            _isPanGestureInteration = NO;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>手势交互管理类的核心代码差不多就这么多，下面我们看看怎么使用</p>
<p>#####4.<code>UIViewController + GLTransition</code></p>
<p>为了和系统的转场动画的函数区分开来，这里我新建了一个<code>UIViewController</code>的<code>category</code>类<code>UIViewController + GLTransition</code>，在其中定义了四个函数，分别如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> push动画</div><div class="line"></div><div class="line"> @param viewController 被push viewController</div><div class="line"> @param transitionManager 控制类</div><div class="line"> */</div><div class="line">- (void)gl_pushViewControler:(UIViewController *)viewController withAnimation:(GLTransitionManager*)transitionManager;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> present动画</div><div class="line"></div><div class="line"> @param viewController 被present viewController</div><div class="line"> @param transitionManager 控制类</div><div class="line"> */</div><div class="line">- (void)gl_presentViewControler:(UIViewController *)viewController withAnimation:(GLTransitionManager*)transitionManager;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> 注册入场手势</div><div class="line"></div><div class="line"> @param direction 方向</div><div class="line"> @param blcok 手势转场触发的点击事件</div><div class="line"> */</div><div class="line">- (void)gl_registerToInteractiveTransitionWithDirection:(GLEdgePanGestureDirection)direction eventBlcok:(dispatch_block_t)blcok;</div><div class="line"></div><div class="line">/**</div><div class="line"> 注册返回手势</div><div class="line"></div><div class="line"> @param direction 侧滑方向</div><div class="line"> @param blcok 手势转场触发的点击事件</div><div class="line"> */</div><div class="line">- (void)gl_registerBackInteractiveTransitionWithDirection:(GLEdgePanGestureDirection)direction eventBlcok:(dispatch_block_t)blcok;</div></pre></td></tr></table></figure></p>
<p>下面我们看看具体实现
<code>UIViewController (GLTransition).m</code>文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">- (void)gl_pushViewControler:(UIViewController *)viewController withAnimation:(GLTransitionManager *)transitionManager</div><div class="line">&#123;</div><div class="line">    if (!viewController) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (!transitionManager) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (self.navigationController) &#123;</div><div class="line">        </div><div class="line">        self.navigationController.delegate = transitionManager;</div><div class="line">        </div><div class="line">        GLInteractiveTransition *toInteractiveTransition = objc_getAssociatedObject(self, &amp;kToAnimationKey);</div><div class="line">        if (toInteractiveTransition) &#123;</div><div class="line">            [transitionManager setValue:toInteractiveTransition forKey:@&quot;toInteractiveTransition&quot;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        objc_setAssociatedObject(viewController, &amp;kAnimationKey, transitionManager, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">        [self.navigationController pushViewController:viewController animated:YES];</div><div class="line">   </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)gl_presentViewControler:(UIViewController *)viewController withAnimation:(GLTransitionManager *)transitionManager</div><div class="line">&#123;</div><div class="line">    if (!viewController) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (!transitionManager) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //present 动画代理 被执行动画的vc设置代理</div><div class="line">    viewController.transitioningDelegate = transitionManager;</div><div class="line">    </div><div class="line">    GLInteractiveTransition *toInteractiveTransition = objc_getAssociatedObject(self, &amp;kToAnimationKey);</div><div class="line">    if (toInteractiveTransition) &#123;</div><div class="line">        [transitionManager setValue:toInteractiveTransition forKey:@&quot;toInteractiveTransition&quot;];</div><div class="line">    &#125;</div><div class="line">    objc_setAssociatedObject(viewController, &amp;kAnimationKey, transitionManager, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">    [self presentViewController:viewController animated:YES completion:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)gl_registerToInteractiveTransitionWithDirection:(GLEdgePanGestureDirection)direction eventBlcok:(dispatch_block_t)blcok</div><div class="line">&#123;</div><div class="line">    GLInteractiveTransition *interactiveTransition = [[GLInteractiveTransition alloc] init];</div><div class="line">    interactiveTransition.eventBlcok = blcok;</div><div class="line">    [interactiveTransition addEdgePageGestureWithView:self.view direction:direction];</div><div class="line">    </div><div class="line">    objc_setAssociatedObject(self, &amp;kToAnimationKey, interactiveTransition, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)gl_registerBackInteractiveTransitionWithDirection:(GLEdgePanGestureDirection)direction eventBlcok:(dispatch_block_t)blcok</div><div class="line">&#123;</div><div class="line">    GLInteractiveTransition *interactiveTransition = [[GLInteractiveTransition alloc] init];</div><div class="line">    interactiveTransition.eventBlcok = blcok;</div><div class="line">    [interactiveTransition addEdgePageGestureWithView:self.view direction:direction];</div><div class="line">    </div><div class="line">    //判读是否需要返回 然后添加侧滑</div><div class="line">    GLTransitionManager *animator = objc_getAssociatedObject(self, &amp;kAnimationKey);</div><div class="line">    if (animator)</div><div class="line">    &#123;</div><div class="line">        //用kvc的模式  给 animator的backInteractiveTransition 退场赋值</div><div class="line">        [animator setValue:interactiveTransition forKey:@&quot;backInteractiveTransition&quot;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>push</code>和<code>present</code>中，有几个需要注意的地方
1、<code>self.navigationController.delegate = transitionManager</code>
2、<code>viewController.transitioningDelegate = transitionManager</code>
上面两个主要是将<code>navigationController</code>的代理和<code>viewController</code>的<code>transitioningDelegate</code>指向对象<code>transitionManager</code>，这个对象是准守了<code>&lt;UINavigationControllerDelegate,UIViewControllerTransitioningDelegate&gt;</code>两个协议的，这样我们就能够在<code>push</code>和<code>present</code>的时候，简单的去调协议方法。</p>
<p>3、设置手势交互转场
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GLInteractiveTransition *toInteractiveTransition = objc_getAssociatedObject(self, &amp;kToAnimationKey);</div><div class="line">if (toInteractiveTransition) &#123;</div><div class="line">    [transitionManager setValue:toInteractiveTransition forKey:@&quot;toInteractiveTransition&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>push</code>和<code>present</code>方法中，都有这样的代码，这里为了减少不必要的暴露，在<code>GLTransitionManager.m</code>文件中，我还定义了两个属性
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 入场手势</div><div class="line"> */</div><div class="line">@property (nonatomic,strong) GLInteractiveTransition *toInteractiveTransition;</div><div class="line"></div><div class="line">/**</div><div class="line"> 退场手势</div><div class="line"> */</div><div class="line">@property (nonatomic,strong) GLInteractiveTransition *backInteractiveTransition;</div></pre></td></tr></table></figure></p>
<p>并且通过<code>kvc</code>的方式对其进行赋值，当转场动画进行的时候，会先去调用非转场动画的方法，比如<code>push</code>的时候，会先调用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC</div></pre></td></tr></table></figure></p>
<p>然后再调用手势交互
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//手势交互 for push or pop</div><div class="line">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController</div></pre></td></tr></table></figure></p>
<p>这个时候，我们就需要加一个判断，也就是通过<code>GLInteractiveTransition</code>类中的是否满足侧滑手势交互<code>isPanGestureInteration</code>这个属性来判断，前面在侧滑手势刚刚进行的时候，就对其进行了赋值，并设置为<code>yes</code>，对应的实现代码就是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController</div><div class="line">&#123;</div><div class="line">    if (_operation == UINavigationControllerOperationPush) &#123;</div><div class="line">        return self.toInteractiveTransition.isPanGestureInteration ? self.toInteractiveTransition:nil;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        return self.backInteractiveTransition.isPanGestureInteration ? self.backInteractiveTransition:nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果返回的为<code>nil</code>，那么就不会去调用手势交互类，否则则会调用。同理，<code>present</code>的时候也是一样
所以就有了下面的代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//手势交互 for dismiss</div><div class="line">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator&#123;</div><div class="line">    return self.backInteractiveTransition.isPanGestureInteration ? self.backInteractiveTransition:nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//手势交互 for present</div><div class="line">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator&#123;</div><div class="line">   return self.toInteractiveTransition.isPanGestureInteration ? self.toInteractiveTransition:nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>UIViewController + GLTransition</code>中的<code>push</code>和<code>present</code>函数中，还有一个需要注意的地方，那就是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(viewController, &amp;kAnimationKey, transitionManager, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div></pre></td></tr></table></figure></p>
<p>这里通过<code>runtime</code>的方式给<code>vc</code>设置了一个属性值，为什么这么做呢？因为在<code>arc</code>下，如果我们在使用<code>GLTransitionManager</code>的时候去创建一个对象而非<code>vc</code>的属性，那么在<code>push</code>的时候<code>GLTransitionManager</code>这个对象就会被系统释放掉，这样我们后面所有有关转场的操作就不能再实现了，或许我们可以给<code>vc</code>建一个<code>base</code>类，然后添加一个<code>GLTransitionManager</code>对象的属性，但是这样或许有点复杂，所有这里就这样处理了。</p>
<p>在<code>UIViewController + GLTransition</code>中还有两个函数的实现，其原理，我相信大家应该都能看明白了，就不再详细说明了
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)gl_registerToInteractiveTransitionWithDirection:(GLEdgePanGestureDirection)direction eventBlcok:(dispatch_block_t)blcok</div><div class="line">&#123;</div><div class="line">    GLInteractiveTransition *interactiveTransition = [[GLInteractiveTransition alloc] init];</div><div class="line">    interactiveTransition.eventBlcok = blcok;</div><div class="line">    [interactiveTransition addEdgePageGestureWithView:self.view direction:direction];</div><div class="line">    </div><div class="line">    objc_setAssociatedObject(self, &amp;kToAnimationKey, interactiveTransition, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)gl_registerBackInteractiveTransitionWithDirection:(GLEdgePanGestureDirection)direction eventBlcok:(dispatch_block_t)blcok</div><div class="line">&#123;</div><div class="line">    GLInteractiveTransition *interactiveTransition = [[GLInteractiveTransition alloc] init];</div><div class="line">    interactiveTransition.eventBlcok = blcok;</div><div class="line">    [interactiveTransition addEdgePageGestureWithView:self.view direction:direction];</div><div class="line">    </div><div class="line">    //判读是否需要返回 然后添加侧滑</div><div class="line">    GLTransitionManager *animator = objc_getAssociatedObject(self, &amp;kAnimationKey);</div><div class="line">    if (animator)</div><div class="line">    &#123;</div><div class="line">        //用kvc的模式  给 animator的backInteractiveTransition 退场赋值</div><div class="line">        [animator setValue:interactiveTransition forKey:@&quot;backInteractiveTransition&quot;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个封装的思路差不多到这里就完了，希望对大家有用</p>
<p>文章有点长，希望大家能够理解，因为后面还有。。。。</p>
<p>####几个动画的具体实现</p>
<p>#####1、开门动画</p>
<p>由于我们已经有了基类``，所以当我们需要实现什么动画的时候，只需要集成该类就可以了</p>
<p>针对开门动画我新建了下面这么一个类<code>GLTransitionManager</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface GLOpenDoorAnimation : GLTransitionManager</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>然后在重新父类的方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setToAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)contextTransition</div></pre></td></tr></table></figure></p>
<p>具体实现
1、根据<code>id&lt;UIViewControllerContextTransitioning&gt;</code>对象先得到几个关键值，目标<code>vc</code>和当前<code>vc</code>和容器<code>containerView</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//获取目标动画的VC</div><div class="line">UIViewController *toVc = [contextTransition viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">UIViewController *fromVc = [contextTransition viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">UIView *containerView = [contextTransition containerView];</div></pre></td></tr></table></figure></p>
<p>2、由于是开门动画，所以其过程大概是这样的：当前<code>vc</code>逐渐缩小，目标<code>vc</code>慢慢从屏幕两边移到中间，但是我们又不能把目标<code>vc</code>的<code>view</code>分成两个部分，所以这里我们可以利用截图，来给用户造成一个假象。先截两个图，然后分别让其坐标居于屏幕外，然后用动画让其慢慢移动到屏幕中间，动画完成的时候，移除当前两个截图。这里有个小问题，那就是当前<code>vc</code>的缩放，虽然我们能够使其缩小，但是这样，如果涉及到侧滑手势的话，问题就来了。因为<code>view</code>的宽发生了变化，这样我们根据宽度来计算滑动的距离，从而更新转场动画的时候就会出现问题，导致
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)handlePopRecognizer:(UIPanGestureRecognizer*)recognizer &#123;</div><div class="line">    // 计算用户手指划了多远</div><div class="line">    </div><div class="line">    CGFloat progress = fabs([recognizer translationInView:self.gestureView].x) / (self.gestureView.bounds.size.width * 1.0);</div><div class="line">    progress = MIN(1.0, MAX(0.0, progress));</div></pre></td></tr></table></figure></p>
<p>中的<code>progress</code>出现问题。所以这里也就采用了截图的方式，对该截图进行缩放，而不去修改<code>vc</code>的<code>view</code>。</p>
<p>下面看下核心代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (void)setToAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)contextTransition</div><div class="line">&#123;</div><div class="line">    //获取目标动画的VC</div><div class="line">    UIViewController *toVc = [contextTransition viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">    UIViewController *fromVc = [contextTransition viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">    UIView *containerView = [contextTransition containerView];</div><div class="line">    </div><div class="line">    UIView *fromView = fromVc.view;</div><div class="line">    UIView *toView = toVc.view;</div><div class="line">    </div><div class="line">    //截图</div><div class="line">    UIView *toView_snapView = [toView snapshotViewAfterScreenUpdates:YES];</div><div class="line">    </div><div class="line">    CGRect left_frame = CGRectMake(0, 0, CGRectGetWidth(fromView.frame) / 2.0, CGRectGetHeight(fromView.frame));</div><div class="line">    CGRect right_frame = CGRectMake(CGRectGetWidth(fromView.frame) / 2.0, 0, CGRectGetWidth(fromView.frame) / 2.0, CGRectGetHeight(fromView.frame));</div><div class="line">    UIView *from_left_snapView = [fromView resizableSnapshotViewFromRect:left_frame</div><div class="line">                                                         afterScreenUpdates:NO</div><div class="line">                                                              withCapInsets:UIEdgeInsetsZero];</div><div class="line">    </div><div class="line">    UIView *from_right_snapView = [fromView resizableSnapshotViewFromRect:right_frame</div><div class="line">                                                         afterScreenUpdates:NO</div><div class="line">                                                              withCapInsets:UIEdgeInsetsZero];</div><div class="line">    </div><div class="line">    toView_snapView.layer.transform = CATransform3DMakeScale(0.7, 0.7, 1);</div><div class="line">    from_left_snapView.frame = left_frame;</div><div class="line">    from_right_snapView.frame = right_frame;</div><div class="line">    </div><div class="line">    //将截图添加到 containerView 上</div><div class="line">    [containerView addSubview:toView_snapView];</div><div class="line">    [containerView addSubview:from_left_snapView];</div><div class="line">    [containerView addSubview:from_right_snapView];</div><div class="line">    </div><div class="line">    fromView.hidden = YES;</div><div class="line">    </div><div class="line">    [UIView animateWithDuration:self.duration delay:0 options:UIViewAnimationOptionCurveEaseOut animations:^&#123;</div><div class="line">        //左移</div><div class="line">        from_left_snapView.frame = CGRectOffset(from_left_snapView.frame, -from_left_snapView.frame.size.width, 0);</div><div class="line">        //右移</div><div class="line">        from_right_snapView.frame = CGRectOffset(from_right_snapView.frame, from_right_snapView.frame.size.width, 0);</div><div class="line">        </div><div class="line">        toView_snapView.layer.transform = CATransform3DIdentity;</div><div class="line">        </div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        fromView.hidden = NO;</div><div class="line">        </div><div class="line">        [from_left_snapView removeFromSuperview];</div><div class="line">        [from_right_snapView removeFromSuperview];</div><div class="line">        [toView_snapView removeFromSuperview];</div><div class="line">        </div><div class="line">        if ([contextTransition transitionWasCancelled]) &#123;</div><div class="line">            [containerView addSubview:fromView];</div><div class="line">        &#125; else &#123;</div><div class="line">            [containerView addSubview:toView];</div><div class="line">        &#125;</div><div class="line">        [contextTransition completeTransition:![contextTransition transitionWasCancelled]];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>setBackAnimation</code>动画和上面的大同小异，就不再详细说明，文章后面有<code>demo</code>地址，大家可以看看。</p>
<p>#####2、圆圈逐渐放大转场动画</p>
<p>在做动画之前，我们先要了解其大概原理
这里我简单的做了个草图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2525768-b0638aceb3247fa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png">
小圆和大圆分别表示动画前和动画后
这里我们采用的是<code>UIBezierPath + mask + CAShapeLayer</code>的策略对其进行实习</p>
<p>大家都知道，<code>UIBezierPath</code>可以画圆形，而<code>CAShapeLayer</code>又具备<code>CGPathRef path</code>属性，可以和<code>UIBezierPath</code>联系起来，而<code>UIView</code>又具备<code>CALayer *mask</code>属性，这样三者就这么巧妙的联系起来了。
在这里，我们使用<code>CABasicAnimation</code>动画，通过对其设置<code>[CABasicAnimation animationWithKeyPath:@&quot;path&quot;]</code>来让其执行我们想要的<code>path</code>路径动画
于是就有了下面的代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (void)setToAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)contextTransition</div><div class="line">&#123;</div><div class="line">    //获取目标动画的VC</div><div class="line">    UIViewController *toVc = [contextTransition viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">    UIView *containerView = [contextTransition containerView];</div><div class="line">    [containerView addSubview:toVc.view];</div><div class="line">    </div><div class="line">    //创建UIBezierPath路径 作为后面动画的起始路径</div><div class="line">    UIBezierPath *startPath = [UIBezierPath bezierPathWithArcCenter:self.centerPoint radius:self.radius startAngle:0 endAngle:2*M_PI clockwise:YES];</div><div class="line">    </div><div class="line">    //创建结束UIBezierPath</div><div class="line">    //首先我们需要得到后面路径的半径  半径应该是距四个角最远的距离</div><div class="line">    CGFloat x = self.centerPoint.x;</div><div class="line">    CGFloat y = self.centerPoint.y;</div><div class="line">    //取出其中距屏幕最远的距离 来求围城矩形的对角线 即我们所需要的半径</div><div class="line">    CGFloat radius_x = MAX(x, containerView.frame.size.width - x);</div><div class="line">    CGFloat radius_y = MAX(y, containerView.frame.size.height - y);</div><div class="line">    //补充下 sqrtf求平方根   double pow(double x, double y); 求 x 的 y 次幂（次方）</div><div class="line">    //通过勾股定理算出半径</div><div class="line">    CGFloat endRadius = sqrtf(pow(radius_x, 2) + pow(radius_y, 2));</div><div class="line">    </div><div class="line">    UIBezierPath *endPath = [UIBezierPath bezierPathWithArcCenter:self.centerPoint radius:endRadius startAngle:0 endAngle:2*M_PI clockwise:YES];</div><div class="line">    </div><div class="line">//    self.endPath = endPath;</div><div class="line">    </div><div class="line">    //创建CAShapeLayer 用以后面的动画</div><div class="line">    CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">    shapeLayer.path = endPath.CGPath;</div><div class="line">    toVc.view.layer.mask = shapeLayer;</div><div class="line">    </div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">    animation.fromValue = (__bridge id _Nullable)(startPath.CGPath);</div><div class="line">    animation.duration = self.duration;</div><div class="line">    animation.delegate = (id)self;</div><div class="line">//    animation.removedOnCompletion = NO;//执行后移除动画</div><div class="line">    //保存contextTransition  后面动画结束的时候调用</div><div class="line">    [animation setValue:contextTransition forKey:@&quot;pathContextTransition&quot;];</div><div class="line">    [shapeLayer addAnimation:animation forKey:nil];</div><div class="line">    </div><div class="line">    self.maskShapeLayer = shapeLayer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于代码中有比较详细的说明，所以这里就不再详细说明，<code>setBackAnimation</code>也大同小异</p>
<p>#####3、圆圈和目标vc共同缩放转场动画</p>
<p>这个比较简单，主要是利用<code>UIView</code>的缩放进行的，由于目标<code>vc</code>的上角和圆是相切的，所以，这里我们可以先假设目标<code>vc</code>处于正常状态，然后再跟进小圆的中心，画一个大圆，让其和目标<code>vc</code>一起缩放就是。这里留了一个缺陷，那就是不支持侧滑，因为我是用目标<code>vc</code>进行缩放的，而没有截图，大家可以试试。
其实现大概为</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">- (CGRect)frameToCircle:(CGPoint)centerPoint size:(CGSize)size</div><div class="line">&#123;</div><div class="line">    CGFloat radius_x = fmax(centerPoint.x, size.width - centerPoint.x);</div><div class="line">    CGFloat radius_y = fmax(centerPoint.y, size.height - centerPoint.y);</div><div class="line">    CGFloat endRadius = 2 * sqrtf(pow(radius_x, 2) + pow(radius_y, 2));</div><div class="line"></div><div class="line">    CGRect rect = &#123;CGPointZero,CGSizeMake(endRadius, endRadius)&#125;;</div><div class="line">    </div><div class="line">    return rect;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)setToAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)contextTransition</div><div class="line">&#123;</div><div class="line">    //获取目标动画的VC</div><div class="line">    UIViewController *toVc = [contextTransition viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">    UIView *containerView = [contextTransition containerView];</div><div class="line">    </div><div class="line">//    [toVc beginAppearanceTransition:YES animated:YES];</div><div class="line">    CGPoint center = toVc.view.center;</div><div class="line">    </div><div class="line">    CGRect rect = [self frameToCircle:self.centerPoint size:toVc.view.bounds.size];</div><div class="line">    UIView *backView = [[UIView alloc] initWithFrame:rect];</div><div class="line">    backView.backgroundColor = UICOLOR_FROM_RGB_OxFF(0xFFA500);</div><div class="line">    backView.center = self.centerPoint;</div><div class="line">    backView.layer.cornerRadius = backView.frame.size.height / 2.0;</div><div class="line">    backView.transform = CGAffineTransformMakeScale(0.01, 0.01);</div><div class="line">    [containerView addSubview:backView];</div><div class="line">    </div><div class="line">    self.startView = backView;</div><div class="line">    </div><div class="line">    toVc.view.transform = CGAffineTransformMakeScale(0.01, 0.01);</div><div class="line">    toVc.view.alpha = 0;</div><div class="line">    toVc.view.center = self.centerPoint;</div><div class="line">    [containerView addSubview:toVc.view];</div><div class="line">    </div><div class="line">    </div><div class="line">    [UIView animateWithDuration:self.duration animations:^&#123;</div><div class="line">        </div><div class="line">        backView.transform = CGAffineTransformIdentity;</div><div class="line">        </div><div class="line">        toVc.view.center = center;</div><div class="line">        toVc.view.transform = CGAffineTransformIdentity;</div><div class="line">        toVc.view.alpha = 1;</div><div class="line">        </div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [contextTransition completeTransition:!contextTransition.transitionWasCancelled];</div><div class="line">        </div><div class="line">//        [toVc endAppearanceTransition];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>setBackAnimation</code>也大同小异，就不再说明</p>
<p>#####4、翻书效果</p>
<p>这个还是花了些时间，主要不在思想上，而是在翻书有个阴影效果哪里，等下我会讲到。先说说思路，主要还是通过截图来实现。首先需要截当前<code>vc</code>的部分，如果向左滑则截右边，向右则截左，然后还需要截目标<code>vc</code>的两部分图，分别加到<code>containerView</code>上，假如现在向左翻，那么就要将目标<code>vc</code>的左边截图加到<code>containerView</code>的左边并且隐藏起来，让其绕<code>y</code>轴旋转<code>M_PI_2</code>，就是直插屏幕的样子，那么目标<code>vc</code>的右边截图就需要放到当前<code>vc</code>的下面，这样当当前<code>vc</code>在滑动的时候，我们就能看到下面的图了。当当前<code>vc</code>绕<code>y</code>轴旋转<code>-M_PI_2</code>的时候，目标<code>vc</code>的左边截图显示出来，并恢复原状，完成整副动画。
需要注意的是，截图在绕<code>y</code>轴旋转的时候，因为我们的<code>layer</code>的默认<code>anchorPoint</code>为<code>(0.5,0.5)</code>，所以需要改变<code>anchorPoint</code>的只，否则就绕中心在旋转了。</p>
<p>说了这么多，还是看看核心代码吧
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">p.p1 &#123;margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Menlo; color: #3d71ff&#125;p.p2 &#123;margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Menlo; color: #4dbf56&#125;p.p3 &#123;margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Menlo; color: #00afca&#125;p.p4 &#123;margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Menlo; color: #3d71ff; min-height: 16.0px&#125;p.p5 &#123;margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Menlo; color: #2337da&#125;p.p6 &#123;margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px &apos;PingFang SC&apos;; color: #4dbf56&#125;span.s1 &#123;font-variant-ligatures: no-common-ligatures&#125;span.s2 &#123;font-variant-ligatures: no-common-ligatures; color: #c2349b&#125;span.s3 &#123;font-variant-ligatures: no-common-ligatures; color: #00afca&#125;span.s4 &#123;font-variant-ligatures: no-common-ligatures; color: #3d71ff&#125;span.s5 &#123;font: 14.0px &apos;PingFang SC&apos;; font-variant-ligatures: no-common-ligatures&#125;span.s6 &#123;font-variant-ligatures: no-common-ligatures; color: #4dbf56&#125;span.s7 &#123;font: 14.0px &apos;PingFang SC&apos;; font-variant-ligatures: no-common-ligatures; color: #4dbf56&#125;span.s8 &#123;font: 14.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #2337da&#125;span.s9 &#123;font: 14.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #3d71ff&#125;span.s10 &#123;font: 14.0px Menlo; font-variant-ligatures: no-common-ligatures&#125;span.s11 &#123;font-variant-ligatures: no-common-ligatures; color: #8b84cf&#125;span.s12 &#123;font-variant-ligatures: no-common-ligatures; color: #93c96a&#125;span.s13 &#123;font-variant-ligatures: no-common-ligatures; color: #d28f5a&#125;</div><div class="line"></div><div class="line">- (void)setToAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)contextTransition</div><div class="line">&#123;</div><div class="line">    //获取目标动画的VC</div><div class="line">    UIViewController *toVc = [contextTransition viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">    UIViewController *fromVc = [contextTransition viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">    UIView *containerView = [contextTransition containerView];</div><div class="line">    </div><div class="line">    //m34 这个参数有点不好理解  为透视效果 我在http://www.jianshu.com/p/e8d1985dccec这里有讲</div><div class="line">    //当Z轴上有变化的时候 我们所看到的透视效果 可以对比看看 当你改成-0.1的时候 就懂了</div><div class="line">    CATransform3D transform = CATransform3DIdentity;</div><div class="line">    transform.m34 = -0.002;</div><div class="line">    [containerView.layer setSublayerTransform:transform];</div><div class="line">    </div><div class="line">    UIView *fromView = fromVc.view;</div><div class="line">    UIView *toView = toVc.view;</div><div class="line">    </div><div class="line">    //截图</div><div class="line">    //当前页面的右侧</div><div class="line">    CGRect from_half_right_rect = CGRectMake(fromView.frame.size.width/2.0, 0, fromView.frame.size.width/2.0, fromView.frame.size.height);</div><div class="line">    //目标页面的左侧</div><div class="line">    CGRect to_half_left_rect = CGRectMake(0, 0, toView.frame.size.width/2.0, toView.frame.size.height);</div><div class="line">    //目标页面的右侧</div><div class="line">    CGRect to_half_right_rect = CGRectMake(toView.frame.size.width/2.0, 0, toView.frame.size.width/2.0, toView.frame.size.height);</div><div class="line">    </div><div class="line">    //截三张图 当前页面的右侧 目标页面的左和右</div><div class="line">    UIView *fromRightSnapView = [fromView resizableSnapshotViewFromRect:from_half_right_rect afterScreenUpdates:NO withCapInsets:UIEdgeInsetsZero];</div><div class="line">    UIView *toLeftSnapView = [toView resizableSnapshotViewFromRect:to_half_left_rect afterScreenUpdates:YES withCapInsets:UIEdgeInsetsZero];</div><div class="line">    UIView *toRightSnapView = [toView resizableSnapshotViewFromRect:to_half_right_rect afterScreenUpdates:YES withCapInsets:UIEdgeInsetsZero];</div><div class="line">    </div><div class="line">    </div><div class="line">    fromRightSnapView.frame = from_half_right_rect;</div><div class="line">    toLeftSnapView.frame = to_half_left_rect;</div><div class="line">    toRightSnapView.frame = to_half_right_rect;</div><div class="line">    </div><div class="line">    //重新设置anchorPoint  分别绕自己的最左和最右旋转</div><div class="line">    fromRightSnapView.layer.position = CGPointMake(CGRectGetMinX(fromRightSnapView.frame), CGRectGetMinY(fromRightSnapView.frame) + CGRectGetHeight(fromRightSnapView.frame) * 0.5);</div><div class="line">    fromRightSnapView.layer.anchorPoint = CGPointMake(0, 0.5);</div><div class="line">    </div><div class="line">    toLeftSnapView.layer.position = CGPointMake(CGRectGetMinX(toLeftSnapView.frame) + CGRectGetWidth(toLeftSnapView.frame), CGRectGetMinY(toLeftSnapView.frame) + CGRectGetHeight(toLeftSnapView.frame) * 0.5);</div><div class="line">    toLeftSnapView.layer.anchorPoint = CGPointMake(1, 0.5);</div><div class="line">    </div><div class="line">    //添加阴影效果</div><div class="line"></div><div class="line">    UIView *fromRightShadowView = [self addShadowView:fromRightSnapView startPoint:CGPointMake(0, 1) endPoint:CGPointMake(1, 1)];</div><div class="line">    UIView *toLeftShaDowView = [self addShadowView:toLeftSnapView startPoint:CGPointMake(1, 1) endPoint:CGPointMake(0, 1)];</div><div class="line">    </div><div class="line">    //添加视图  注意顺序</div><div class="line">    [containerView insertSubview:toView atIndex:0];</div><div class="line">    [containerView addSubview:toLeftSnapView];</div><div class="line">    [containerView addSubview:toRightSnapView];</div><div class="line">    [containerView addSubview:fromRightSnapView];</div><div class="line"></div><div class="line">    toLeftSnapView.hidden = YES;</div><div class="line">    </div><div class="line">    </div><div class="line">    //先旋转到最中间的位置</div><div class="line">    toLeftSnapView.layer.transform = CATransform3DMakeRotation(M_PI_2, 0, 1, 0);</div><div class="line">    //StartTime 和 relativeDuration 均为百分百</div><div class="line">    [UIView animateKeyframesWithDuration:self.duration delay:0 options:UIViewKeyframeAnimationOptionCalculationModeLinear animations:^&#123;</div><div class="line">        [UIView addKeyframeWithRelativeStartTime:0 relativeDuration:0.5 animations:^&#123;</div><div class="line">            </div><div class="line">            fromRightSnapView.layer.transform = CATransform3DMakeRotation(-M_PI_2, 0, 1, 0);</div><div class="line">            fromRightShadowView.alpha = 1.0;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.5 animations:^&#123;</div><div class="line">            toLeftSnapView.hidden = NO;</div><div class="line">            toLeftSnapView.layer.transform = CATransform3DIdentity;</div><div class="line">            toLeftShaDowView.alpha = 0.0;</div><div class="line">        &#125;];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [toLeftSnapView removeFromSuperview];</div><div class="line">        [toRightSnapView removeFromSuperview];</div><div class="line">        [fromRightSnapView removeFromSuperview];</div><div class="line">        [fromView removeFromSuperview];</div><div class="line">        </div><div class="line">        if ([contextTransition transitionWasCancelled]) &#123;</div><div class="line">            [containerView addSubview:fromView];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [contextTransition completeTransition:![contextTransition transitionWasCancelled]];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">//本来打算用基础动画来实现 但是由于需要保存几个变量 在动画完成的代理函数中用，所以就取消这个想法了</div><div class="line">//    CABasicAnimation *fromRightAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.x&quot;];</div><div class="line">//    fromRightAnimation.duration = self.duration/2.0;</div><div class="line">//    fromRightAnimation.beginTime = CACurrentMediaTime();</div><div class="line">//    fromRightAnimation.toValue = @(-M_PI_2);</div><div class="line">//    [fromRightSnapView.layer addAnimation:fromRightAnimation forKey:nil];</div><div class="line">//    </div><div class="line">//    </div><div class="line">//    CABasicAnimation *toLeftAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.x&quot;];</div><div class="line">//    toLeftAnimation.beginTime = CACurrentMediaTime() + self.duration/2.0;</div><div class="line">//    toLeftAnimation.fromValue = @(M_PI_2);</div><div class="line">//    [toLeftAnimation setValue:contextTransition forKey:@&quot;contextTransition&quot;];</div><div class="line">//    [toLeftSnapView.layer addAnimation:toLeftAnimation forKey:@&quot;toLeftAnimation&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写到这里，差不多转场动画我能够写的就到这里了，文章实在是有点长，不是故意为之，只是我想写的稍微详细点，对自己也是一个很好的提升。如果能帮到你，还请给个<code>star</code>，嘿嘿~
下面就附上<a href="https://github.com/gao211326/GLTransitionAnimationDemo" target="_blank" rel="external">demo</a>地址
如果有什么不对的地方，还请多多指教，共同成长。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 One Dream
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 4;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>